function main()
    % Add path
    addpath('./simulation_scripts');
    addpath('./tools')
    addpath('./icat')
    addpath('./tasks')
    close all; 
    clear; 
    clc; 

    % Simulation Setup
    real_robot = false;

    % Simulation Parameters
    dt = 0.005;
    end_time = 40;
    
    % Print on terminal parameters
    print_frequency = 2;
    print_interval = 1 / print_frequency;
    last_print_time = 0;

    % Action manager parameters
    action_transition_duration = 1;     % 1 second 
    n_dofs = 14;

    % Cartesian error thresholds for tool and obj
    ang_error_threshold = 0.02;
    lin_error_threshold = 0.001;
    obj_ang_error_threshold = 0.02;
    obj_lin_error_threshold = 0.001;
    % Table edge threshold: we assumed that the object lies on a table,
    % which the robot has to avoid while moving the object to the object
    % goal position. After the robot clears the table edge, the minimum
    % altitude is computed wrt the floor instead of the table
    table_edge_threshold = 0.58; 

    % Initialize Franka Emika Panda Model
    model = load("panda.mat");

    % Initiliaze pandaArm() Class, specifying the base offset w.r.t World Frame
    left_arm = PandaArm(model, eye(4));
    % TO DO: TRANSFORMATION MATRIX FROM WORLD FRAME TO RIGHT ARM BASE FRAME
    wTb2 = [-1  0   0   1.06;
            0   -1  0   -0.01;
            0   0   1   0;
            0   0   0   1];
    right_arm = PandaArm(model, wTb2);
 
    % Initialize Bimanual Simulator Class
    bm_sim = bimanual_sim(dt, left_arm, right_arm, end_time);
    
    % Define Object Shape and origin Frame
    obj_length = 0.10;
    w_obj_pos = [0.5 0 0.59]';
    w_obj_ori = rotation(0, 0, 0);
    wTo_obj = [w_obj_ori, w_obj_pos; 0 0 0 1];

    % Compute tool goal frame offset wrt to object frame
    offset = (obj_length/2) - 0.01;     % offset with a margin to not take the obj exactly at the end
    linear_offset = [offset 0 0]';
    % Set goal frames for left and right arm, based on object frame
    left_arm.setGoal(w_obj_pos, w_obj_ori, -linear_offset, rotation(pi, -pi/6, 0));    
    right_arm.setGoal(w_obj_pos, w_obj_ori, +linear_offset, rotation(pi, pi/6, 0));

    % Define Object goal frame for bimanual motion of the object
    wTog = [rotation(0, 0, 0) [0.65, -0.35, 0.28]'; 0 0 0 1];
    left_arm.setObjGoal(wTog)
    right_arm.setObjGoal(wTog)

    % -------------
    % --- TASKS ---
    % -------------

    % Tool tasks
    left_tool_task = ToolTask("L", "Left Tool");
    right_tool_task = ToolTask("R", "Right Tool");

    % Joint limits task
    % left_joint_task = JointLimitsIndividualTask("L", "LJL");
    % right_joint_task = JointLimitsIndividualTask("R", "RJL");
    joint_limits_task = JointLimitsTask("BM", "Joint Limits");
 
    % Task minimum altitude
    left_min_alt_task = MinEffectorAltitudeTask("L", "Left Min. Alt.");
    right_min_alt_task = MinEffectorAltitudeTask("R", "Right Min. Alt.");

    % Task object kinematic constraint (unique for both arms)
    kin_constraint_task = KinConstraintTask("BM", "Kinematic Constraint");

    % Task object
    object_task = ObjectTaskMasterSlave("BM", "Object"); 
    % object_task = ObjectTaskSymmetric("L", "LO");

    % ---------------
    % --- ACTIONS ---
    % ---------------

    % NB: Compared to the original implementation, the order in which we add
    % tasks to the action is not relevant for priorities, which are decided
    % in the unified list instead
    action_move_to = Action("MoveTo", {joint_limits_task, ...
                                            left_min_alt_task, right_min_alt_task ...
                                            left_tool_task, right_tool_task});
    action_move_obj = Action("MoveObj", {kin_constraint_task, ...
                                            joint_limits_task, ...
                                            left_min_alt_task, right_min_alt_task, ...
                                            object_task});
    action_stop = Action("Stop", {joint_limits_task, ...
                                            left_min_alt_task, right_min_alt_task});

    % Order defines priority { HIGHEST , ... , lowest}
    unified_list = {kin_constraint_task, ...
                    joint_limits_task, ...
                    left_min_alt_task, right_min_alt_task, ...
                    object_task, ...
                    left_tool_task, right_tool_task};

    % Load Action Manager Class and load actions
    actionManager = ActionManager(dt, n_dofs, action_transition_duration);
    actionManager.addUnifiedList(unified_list);
    actionManager.addAction(action_move_to);
    actionManager.addAction(action_move_obj);
    actionManager.addAction(action_stop);
    actionManager.setCurrentAction("MoveTo");   % Explicitly start with the MoveTo action

    % Initiliaze robot interface
    robot_udp = UDP_interface(real_robot);

    % Initialize logger
    logger = SimulationLogger(ceil(end_time/dt)+1, bm_sim, unified_list);

    % Flags 
    mission_completed = false;
    table_edge_passed = false;

    % ===========================
    %    MAIN SIMULATION LOOP
    % ===========================
    for t = 0:dt:end_time
        
        % Receive UDP packets - DO NOT EDIT
        [ql, qr] = robot_udp.udp_receive(t);
        if real_robot == true 
            bm_sim.left_arm.q = ql;
            bm_sim.right_arm.q = qr;
        end
        
        % Update Full kinematics of the bimanual system
        bm_sim.update_full_kinematics();

        % Handle different logic for each mission phase
        switch actionManager.getCurrentActionName()
            
            case "MoveTo"
                % Compute tool errors
                left_ang_error = norm(left_arm.rot_to_goal);
                left_lin_error = norm(left_arm.dist_to_goal);
                right_ang_error = norm(right_arm.rot_to_goal);
                right_lin_error = norm(right_arm.dist_to_goal);
                
                % Feedback on terminal
                if (t - last_print_time > print_interval)
                    fprintf('Action: MoveTo  | t: %.2f | L_Lin: %.4f L_Ang: %.4f | R_Lin: %.4f R_Ang: %.4f\n', ...
                            t, left_lin_error, left_ang_error, right_lin_error, right_ang_error);
                    last_print_time = t;
                end
                
                % Check thresholds: if we got to the goal switch to next action
                if (left_ang_error < ang_error_threshold) && (left_lin_error < lin_error_threshold) && ...
                   (right_ang_error < ang_error_threshold) && (right_lin_error < lin_error_threshold)
                   
                    disp(['Target Reached at t = ' num2str(t) '. Switching to MoveObj.']);
                             
                    % Compute current obj position relative to current arm pose
                    tTo_L = invT(left_arm.wTt) * wTo_obj;
                    tTo_R = invT(right_arm.wTt) * wTo_obj;
                    
                    % Set the obj/tool transforms 
                    left_arm.setObjToolTransform(tTo_L);
                    right_arm.setObjToolTransform(tTo_R);
                
                    % Force update of Jacobians/Transforms
                    left_arm.updateTransform();
                    right_arm.updateTransform();
                    left_arm.updateJacobian();
                    right_arm.updateJacobian();
                    
                    % Switch to next action
                    actionManager.setCurrentAction("MoveObj");
                end

            case "MoveObj"

                % Current x position of the left arm, we check just one for
                % simplicity as they're kinematically constrained to each other
                current_obj_x = left_arm.wTo(1,4); 
            
                if current_obj_x > table_edge_threshold && ~table_edge_passed
                    % If we cleared the table edge we can now set the
                    % ground as the new obstacle to keep a minimum altitude from
                    left_min_alt_task.setObstacleHeight(0);
                    right_min_alt_task.setObstacleHeight(0);
                    
                    table_edge_passed = true;
                    disp(['t = ' num2str(t) ' - Table edge cleared.']);
                end
                
                % Compute object error for both arms
                [left_obj_err_ori, left_obj_err_lin] = CartError(left_arm.wTog, left_arm.wTo);
                left_obj_ang_err = norm(left_obj_err_ori);
                left_obj_lin_err = norm(left_obj_err_lin);

                [right_obj_err_ori, right_obj_err_lin_R] = CartError(right_arm.wTog, right_arm.wTo);
                right_obj_ang_err = norm(right_obj_err_ori);
                right_obj_lin_err = norm(right_obj_err_lin_R);

                % Feedback on terminal
                if (t - last_print_time > print_interval)
                    fprintf('Action: MoveObj | t: %.2f | Obj_L_Lin: %.4f Obj_L_Ang: %.4f | Obj_R_Lin: %.4f Obj_R_Ang: %.4f\n', ...
                            t, left_obj_lin_err, left_obj_ang_err, right_obj_lin_err, right_obj_ang_err);
                    last_print_time = t;
                end
                
                % Check thresholds (we check both for safety even if, if the constraint works perfectly, one should probably be enough)
                if (left_obj_ang_err < obj_ang_error_threshold) && (left_obj_lin_err < obj_lin_error_threshold) && ...
                   (right_obj_ang_err < obj_ang_error_threshold) && (right_obj_lin_err < obj_lin_error_threshold)
                   
                    disp(['Object moved to position at t = ' num2str(t) '. Switching to Stop.']);
                    
                    % Switch to stop action
                    actionManager.setCurrentAction("Stop");
                end

            case "Stop"
                if ~mission_completed
                    disp("MISSION COMPLETED");
                    mission_completed = true;
                end
                
                % Feedback on terminal
                if (t - last_print_time > print_interval)

                end

        end
        
        % Compute control commands for current action
        [q_dot] = actionManager.computeICAT(bm_sim);
        
        % Step the simulator (integrate velocities)
        bm_sim.sim(q_dot);
        
        % Send updated state to Pybullet
        robot_udp.send(t, bm_sim)
        
        % Logging
        logger.update(bm_sim.time, bm_sim.loopCounter)
        
        % Optional real-time slowdown
        SlowdownToRealtime(dt);
    end

    logger.plotAll();
end
